# Native Module Generator
If we have a library written in C and want to call this library through the OX language, we need to write a native module to encapsulate this C library.
We can use the native module generator "oxngen" program to automatically generate the C code for this encapsulated native module.
Note that "oxngen" needs to call clang to parse the header file and generate an abstract syntax tree. Please install clang before using "oxngen".
During the parsing process, "oxngen" will generate the source code of the native module according to the rules defined in the "build.ox" file, and users can define generation rules in the "build.ox" file.
## Example
Suppose we have a library implemented in C, and its header file "test.h" contains the function definition:
```
extern void test (int a);
```
We edit the "build.ox" to describe the native module generation rules:
```
{
    ...

    oxngen_targets: {
        //Generate the source file "test.oxn.c" of the native module
        test: {
            input_files: [
                "test.h" //Scan the header file "test.h"
            ]
        }
    }

    ...
}
```
Run "oxngen" to generate the source file "test.oxn.c" of the native module:
```
ox -r oxngen -i build.ox
```
Run gcc to generate the native module "test.oxn":
```
gcc -o test.oxn.o -c -fPIC test.oxn.c
gcc -o test.oxn -shared test.oxn.o -lox -lm -lpthread -ldl -lffi
```
## Generated Code
"oxngen" can generate corresponding encapsulation code for macros, enumerations, data structures, variables, and functions in the header file.
### Macros
Macros with numeric or string values in the header file can generate corresponding OX code. For example, the header file defines:
```
#define M_NUM 1
#define M_STR "hello"
```
"oxngen" will generate constants "M_NUM" and "M_STR". These symbols of the generated module can be referenced in the OX script:
```
ref "test" //Reference the module generated by "oxngen"

stdout.puts("{M_NUM}\n") //Print  1
stdout.puts("{M_STR}\n") //Print "hello"
```
### Enumerations
The header file defines an enumeration type:
```
enum {
    E_ITEM_0,
    E_ITEM_1,
    E_ITEM_2
};
```
"oxngen" will generate numeric constants "E_ITEM_0", "E_ITEM_1", and "E_ITEM_2". These symbols of the generated module can be referenced in the OX script:
```
ref "test" //Reference the module generated by "oxngen"

stdout.puts("{E_ITEM_0} {E_ITEM_1} {E_ITEM_2}\n") //Print 0 1 2
```
### Data Structures
The header file defines a data structure:
```
typedef struct {
    int a;
    int b;
} MyStruct;
```
"oxngen" will generate a data structure object "MyStruct". By calling this object, you can allocate instances of the data structure or arrays of the data structure.
These symbols of the generated module can be referenced in the OX script:
```
ref "test" //Reference the module generated by "oxngen"

s = MyStruct() //Allocate a data structure and return a pointer to the MyStruct data structure.
s.{
    a: 1 //Set s.a = 1
    b: 2 //Set s.b = 2
}

sa = MyStruct(4) //Allocate an array of data structures and return a pointer to the array
for i = 0; i < C.get_length(sa); i+=1 {
    sa[i] = s //Set array elements
}
```
### Variables
The header file defines a variable:
```
int my_var = 1;
```
"oxngen" will generate an object "my_var". The variable can be read and set through the "get" and "set" methods of the object. These symbols of the generated module can be referenced in the OX script:
```
ref "test" //Reference the module generated by "oxngen"

stdout.puts("{my_var.get()}\n") //Print 1

my_var.set(1978) //Set the variable

stdout.puts("{my_var.get()}\n") //Print 1978
```
### Functions
The header file declares a function:
```
int my_func(int a, int *p);
```
"oxngen" will generate a C function object "my_func". This function can be called in the OX script:
```
ref "test" //Reference the module generated by "oxngen"

i = Int32()

r = my_func(100, &i) //Call the function
```
In the generated encapsulation code of the function, automatic type conversion will be performed on the parameters.

* For parameters of numeric types (char/int/float/double...), if an OX numeric value is input, it will be automatically converted to the corresponding C type value.
* For parameters of string type, if an OX string is input, it will be automatically converted to a C string. Note that if the function modifies the data in the string, do not pass an OX string as a parameter, because OX strings are immutable.

## Generation Rules
To use "oxngen", add the "oxngen_targets" attribute to "build.ox". Its value is an object, and each attribute name of the object is the name of the native module to be generated.
For example, the attribute "test" represents generating the module "test.oxn", and the corresponding generated source file is "test.oxn.c".
The attribute value object is the rule used to generate this module.
### Input Files
The attribute "input_files" represents the input header files. Its value is an array of strings, and each element represents an input header file. For example:
```
input_files: [
    "my_module.h"
    "my_mudule_helper.h"
]
```
### Compilation and Linking Options:
The attribute "cflags" indicates the compilation options of the module, and "libs" indicates the linking options of the module. For example:
```
    cflags: "-I/usr/include/my_module -DVERSION=20260101"
    libs: "-lmy_module"
```
### File Filters
Since the header file includes many other header files through "#include", you can choose to generate encapsulation code only for definitions in some header files. For example:
```
    file_filters: [
        "my_module.h"
        "my_mudule_helper.h"
    ]
```
The above definition means that only the definitions in the header files "my_module.h" and "my_mudule_helper.h" will generate corresponding encapsulation code.

If you only want to skip some header files, you can define reverse filtering:
```
    rev_file_filters: [
        "stdio.h"
    ]
```
The above definition means skipping the definitions in "stdio.h".
### Declaration Filters
Sometimes we only want to generate OX encapsulation code for part of the definitions in the header file, which can be achieved through declaration filters. For example:
```
    decl_filter: [
        "test_func"
        /TEST_.+/p
    ]
```
The declaration filter is an array, and its elements can be strings or regular expressions. Encapsulation code will be generated for a definition only if the definition name matches an element.
For example, using the above declaration filter to scan the header file:
```
enum {
    TEST_1,
    TEST_2
};

void test_func(void)
```
will generate encapsulation corresponding to the enumeration values "TEST_1", "TEST_2" and the function "test_func".

If you want to skip certain definitions, you can use the reverse declaration filter "rec_decl_filters". For example:
```
    rev_decl_filters: [
        "TEST_2"
    ]
```
When scanning the above header file, the encapsulation corresponding to the enumeration value "TEST_2" will not be generated.
### Macro Constants
Sometimes we want to encapsulate numeric or string constants defined by macros in the header file.
This can be described through "number_macros" and "string_macros":
```
    number_macros: [
        "MY_PI"
        /NUM_,+/p
    ]
    string_macros: [
        "VERSION_STRING"
    ]
```
The elements of "number_macros" and "string_macros" can be strings or regular expressions. Scanning the header file with the above definitions:
```
#define MY_PI   3.1415926
#define NUM_ITEM1 1
#define NUM_ITEM2 (NUM_ITEM1 + 1)

#define VERSION_STRING "1.0.0"
```
will generate constants "MY_PI", "NUM_ITEM1", "NUM_ITEM2" and "VERSION_STRING".
### References
If the module contains references to other modules, it can be defined through "references". For example:
```
    references: {
        "std/socket": [
            "sockaddr"
        ]
    }
```
The value of "references" is an array, where the name of each attribute represents the name of the referenced module, and the attribute value is an array representing the names of public symbols in the referenced module.
The above definition means that the module references the symbol "sockaddr" defined in "std/socket".