# 正则表达式
## 概述
正则表达式用于对字符串进行匹配。看下面的例子：
```
/[a-z]+/i
```
以上语句声明了一个正则表达式。在一对"/"符号中间是正则表达式的匹配模式定义。
在后一个"/"后面，是正则表达式的属性标识，此处属性标识"i"表示忽略大小写。
利用这个正则表达式我们可以对字符串进行匹配：
```
“123 Hello ?” ~ /[a-z]+/i //返回"Hello"
“123 Hello ?”.match(/[a-z]+/i) //返回一个Match对象
“123?” ~ /[a-z]+/i //返回null
```

语法描述：
```
regular_expression: "/" regular_expression_conditions "/" regular_expression_flag*

regular_expression_pattern: regular_expression_conditions

regular_expression_conditions: regular_expression_conditions "|" regular_expression_condition
    | regular_expression_condition

regular_expression_condition: regular_expression_item*

regular_expression_item: regular_expression_match regular_expression_times? "?"?
    | "^"
    | "$"

regular_expression_match: "."
    | regular_expression_character
    | "\s"
    | "\S"
    | "\d"
    | "\D"
    | "\w"
    | "\W"
    | "\b"
    | "\B"
    | "[" regular_expression_class_item* "]"
    | "[^" regular_expression_class_item* "]"
    | "(" regular_expression_pattern ")"
    | "(:" regular_expression_pattern ")"
    | "(?=" regular_expression_pattern ")"
    | "(?!" regular_expression_pattern ")"
    | "(?<=" regular_expression_pattern ")"
    | "(?<!" regular_expression_pattern ")"
    | "\" decimal_integer

regular_expression_character: 除了"/", "\", "|", "(", ")", "[", "]", ".", "^", "$"以外的所有可打印ASCII字符

regular_expression_class_item: regular_expression_class_character
    | regular_expression_class_character "-" regular_expression_class_character
    | "\s"
    | "\S"
    | "\d"
    | "\D"
    | "\w"
    | "\W"

regular_expression_class_character: 除了"]", "-"以外的所有可打印ASCII字符

regular_expression_times: "?"
    | "+"
    | "*"
    | "{" decimal_integer "}"
    | "{" decimal_integer "," "}"
    | "{" decimal_integer "," decimal_integer "}"

regular_expression_flag: "i"
    | "m"
    | "a"
    | "u"
    | "p"
```
## 匹配对象
一个字符串调用"match"属性函数，如果匹配成功返回一个Match对象。Math对象包含以下属性：

|属性|类型|描述|
|:-|:-|:-|
|$to_str()|返回值为字符串|返回匹配字符串|
|start|正整数|匹配字符串在原字符串中的起始位置(第一个字符的索引值)|
|end|正整数|匹配字符串在原字符串中的结束位置(最后一个字符的索引值+1)|
|groups|字符串数组|数组元素0为匹配字符串，其余元素对应匹配子模式匹配字符串|
|slices|[start, end]位置数组|每个元素为一个2元素数组，对应每个匹配字符串的起始和结束位置|

## 语法
### 属性标识
|属性|说明|
|:-|:-|
|i|忽略大小写|
|m|多行匹配，行结束"$"可以匹配LF换行，没有这个属性"$"只能匹配字符串末尾|
|a|"."可以匹配任意字符(包括LF换行)，没有这个属性"."不能匹配LF|
|u|unicode匹配，没有这个属性按照ASCII进行匹配|
|p|字符串完全匹配，没有这个属性正则表达式可以匹配字符串的一个子串|

### 任意字符匹配
"."用于匹配任意字符：
```
"a" ~ /./ //返回"a"
"1" ~ /./ //返回"1"
" " ~ /./ //返回" "
"" ~ /./ //字符串为空，无法匹配"."，返回null
```
注意如果正则表达式没有"a"属性时，"."不能匹配LF换行符：
```
"\n" ~ /./ //返回null
"\n" ~ /./a //返回"\n"
```
### 字符匹配
ASCII可显示字符，除了特殊命令字符"/", "\", "|", "(", ")", "[", "]", ".", "^", "$"外，可用于匹配单个字符。
```
/a/ //匹配字符"a"
/A/ //匹配字符"A"
/0/ //匹配字符"0"
/!/ //匹配字符"!"
/ / //匹配空格符" "
```
通过转义字符"\"可以用来匹配一些特殊字符：
```
/\n/ //匹配LF换行
/\r/ //匹配CR回车
/\t/ //匹配HT水平制表符
/\v/ //匹配VT垂直制表符
/\f/ //匹配FF(form feed)
/\a/ //匹配BEL(bell)
/\b/ //匹配BS(backspace)
/\// //匹配"/"
/\\/ //匹配"\"
/\|/ //匹配"|"
/\x41/ //匹配ASCII编码为0x41的字符("A")
/\u0041/ //匹配unicode编码为0x0041的字符("A")
/\u{41}/ //匹配unicode编码为0x41的字符("A")
```
多个字符用于匹配一段字符序列：
```
/abc/ //匹配子字符串"abc"
/123\|/ //匹配子字符串"123|"
```
### 类型字符匹配
通过类型字符匹配，可以匹配一类特殊字符，包括：

|类型|描述|
|:-|:-|
|\s|空白字符,包括" ", "\t", "\v", "\f", "\n", "\r"|
|\S|非空白字符, 除" ", "\t", "\v", "\f", "\n", "\r"外的其他字符|
|\d|数字字符，包括"0" ~ "9"|
|\D|非数字, 除"0" ~ "9"外的其他字符|
|\w|word字符，包括"0" ~ "9", "a" ~ "z", "A" ~ "Z", "_"|
|\W|非word字符, 除"0" ~ "9", "a" ~ "z", "A" ~ "Z", "_"外的其他字符|

如：
```
"A " ~ /\s/ //返回" "
"A\t" ~ /\s/ //返回"\t"
" \tA" ~ /\S/ //返回"A"
"0" ~ /\d/ //返回"0"
"9" ~ /\d/ //返回"9"
"0123456789A" ~ /\D/ //返回"A"
" A" ~ /\w/ //返回"A"
" 0" ~ /\w/ //返回"0"
" _" ~ /\w/ //返回"_"
" a" ~ /\W/ //返回" "
```

### 行开始匹配
用"^"可以匹配行开始：
```
"abc" ~ /^abc/ //返回"abc"
"123abc" ~ /^abc/ //"abc“没有出现在开始位置，返回null
```
注意如果正则表达式没有加"m"属性时，"^"只能匹配字符串的开始，当正则表达式加了"m"属性时，"^"可以匹配所有行的开始位置(包括LF换行符后):
```
"123\nabc" ~ /^abc/ //返回null
"123\nabc" ~ /^abc/m //返回"abc"
```
### 行末尾匹配
用"$"可以匹配行末尾：
```
"abc" ~ /abc$/ //返回"abc"
"abc123" ~ /abc$/ //"abc“没有出现在末尾，返回null
```
注意如果正则表达式没有加"m"属性时，"$"只能匹配字符串的末尾，当正则表达式加了"m"属性时，"$"可以匹配所有行的末尾位置(包括LF换行符前):
```
"abc\n123" ~ /abc$/ //返回null
"abc\n123" ~ /abc$/m //返回"abc"
```
### word边界匹配
用"\b"可以匹配word边界位置，即此位置前后两个字符分别为word字符或其他(非word字符或行开始/末尾)。
如：
```
"12abc34" ~ /\babc\b/ //"abc"两侧不是边界，所以返回null
"123 abc 456" ~ /\babc\b/ //返回"abc"
"123 abc" ~ /\babc\b/ //返回"abc"
```
"\B"表示匹配非word边界位置，如：
```
"12abc34" ~ /\Babc\B/ //返回"abc"
"123 abc 456" ~ /\Babc\B/ //返回null
"123 abc" ~ /\Babc\B/ //返回null
```
### 字符集匹配
用一对"["和"]"命令表示一个字符集，用来匹配这个字符集中的任意一个字符：
```
/[abc]/ //可以匹配"a","b","c"中的任意一个字符
/[a-z]/ //可以匹配任意小写字母
/[\s0-9,]/ //可以匹配所有空白字符，"0" ~ "9"和字符","
```
在字符集最前面加入字符"^"，表示反相匹配，即字符不在这个集合中时匹配成功：
```
/[^a-zA-Z]/ //匹配非字母字符
/[^0-9]/ //匹配非数字字符
```
### 匹配次数标识
在每个匹配命令后可以加入匹配次数标识，表示需要匹配的次数：

|标识|描述|
|:-|:-|
|?|匹配0次或1次|
|+|匹配1次或任意多次|
|*|匹配0次或任意多次|
|{N}|匹配N次|
|{N,M}|最少匹配N次，最多匹配M次|
|{N,}|最少匹配N次，最多匹配任意多次|

如：
```
"" ~ /a?/ //匹配0次，返回""
"aa" ~ /a?/ //匹配1次，返回"a"
"" ~ /a+/ //返回null
"a" ~ /a+/ //匹配1次，返回"a"
"aa" ~ /a+/ //匹配2次，返回"aa"
"aaa" ~ /a+/ //匹配3次，返回"aaa"
"" ~ /a*/ //匹配0次，返回""
"a" ~ /a*/ //匹配1次，返回"a"
"aa" ~ /a*/ //匹配2次，返回"aa"
"aaa" ~ /a*/ //匹配3次，返回"aaa"
"a" ~ /a{2,3}/ //返回null
"aa" ~ /a{2,3}/ //返回"aa"
"aaaa" ~ /a{2,3}/ //最多匹配3次，返回"aaa"
```
### 贪婪模式和非贪婪模式
看以下正则表达式：
```
/[a-z]+a/
```
用这个表达式匹配字符串"abcaba", 前3个字符"abc"匹配"[a-z]+"成功，当开始匹配第四个字符"a"时，我们可以继续匹配"[a-z]+", 也可以匹配后面的命令"a"。
我们称前一种优先处理多次匹配的方式为贪婪模式，后一种优先处理后续命令的方式为非贪婪模式。

"OX"正则表达式缺省采用贪婪模式。在一个匹配命令后加入"?"表示采用非贪婪模式：
```
"abcaba" ~ /[a-z]+a/ //贪婪模式，返回"abcaba"
"abcaba" ~ /[a-z]+?a/ //非贪婪模式，返回"abca"
```
### 前瞻匹配
有时我们希望匹配只发生在某些特定匹配发生之前，这时我们可以使用前瞻匹配：
```
/[a-z]+(?=[0-9])/
```
在"(?="和")"中间定义需要前瞻匹配"[0-9]"成功，"[a-z]+"匹配才能成功。所以：
```
"abcd" ~ /[a-z]+(?=[0-9])/ //不满足前瞻条件，返回null
"abc0" ~ /[a-z]+(?=[0-9])/ //满足前瞻条件，返回"abc"
```
另外还可以用"(?!"和")"表示反向前瞻，即只有前瞻不满足时，整个匹配才能成功：
```
"abcd" ~ /[a-z]+(?![0-9])/ //不满足前瞻条件，返回"abcd"
"abc0" ~ /[a-z]+(?![0-9])/ //满足前瞻条件，返回null
```
### 回看匹配
类似前瞻匹配，我们还可以通过回看匹配定义只有特定匹配发生之后，整个匹配才能成功：
```
/(?<=[0-9])[a-z]+/
```
"(?<="和")"中间定义回看匹配模式。
```
"abc" ~ /(?<=[0-9])[a-z]+/ //不满足回看条件，返回null
"zabc" ~ /(?<=[0-9])[a-z]+/ //不满足回看条件，返回null
"0abc" ~ /(?<=[0-9])[a-z]+/ //满足回看条件，返回"abc"
```
与前瞻匹配类似，可以通过"(?<!"和")"定义反向回看，只有反向回看不匹配时，整个匹配才能成功：
```
"abc" ~ /(?<![0-9])[a-z]+/ //不满足回看条件，返回"abc"
"zabc" ~ /(?<![0-9])[a-z]+/ //不满足回看条件，返回"zabc"
"0abc" ~ /(?<![0-9])[a-z]+/ //满足回看条件，返回null
```
### 子模式
当一个匹配模式比较复杂时，可以通过"(:"和")"打包一些子模式。
```
"var=1978" ~ /(:[a-z]+)=(:[0-9]+)/ //返回"var=1978"
```
正则表达式中定义了两个子模式"(:[a-z]+)"和"(:[0-9]+)"。
### 匹配子模式
有时候在匹配时我们不仅需要获取完整的匹配字符串，还希望获取每个子模式对应的字符串。我们可以定义匹配子模式来获取这些子字符串。
在正则表达式中，通过一对小括号"("和")"，我们可以定义一个匹配子模式：
如：
```
m = "var=1978".match(/([a-z]+)=([0-9]+)/)
stdout.puts("match: {m}\n") //打印"var=1978"
stdout.puts("start: {m.start} end: {m.end}\n") //打印匹配开始和结束位置 0 和 8
stdout.puts("name: {m.groups[1]}\n") //打印第一个匹配子模式匹配的字符串"var"
stdout.puts("name start: {m.slices[1][0]} end: {m.slices[1][1]}\n") //打印第一个匹配子模式匹配的开始和结束位置 0 和 3
stdout.puts("value: {m.groups[2]}\n") //打印第二个匹配子模式匹配的字符串"1978"
stdout.puts("value start: {m.slices[2][0]} end: {m.slices[2][1]}\n") //打印第一个匹配子模式匹配的开始和结束位置 4 和 8
```
### 反向引用匹配
在匹配命令中，有时候我们需要引用前面的一个已经匹配的字符串，这时我们可以用反向引用匹配。
在反斜杠"\"后根一个10进制数字，表示匹配子模式的序号(从1开始)。
如：
```
/([a-z]+)=\1_value/
```
正则表达式中"\1"表示引用匹配子模式1匹配的字符串：
```
"abc=abc_value" ~ /([a-z]+)=\1_value/ //返回"abc=abc_value"
"def=def_value" ~ /([a-z]+)=\1_value/ //返回"def=def_value"
```
### 多选项匹配
通过"|"可以列出多个匹配选项：
```
/LiuBang|XiangYu|ZhangHan/
```
正则表达式中有三个匹配选项，匹配时会从左到右依次尝试各个选项，如果一个选项匹配成功则返回这个匹配结果，否则尝试下一个选项。如果全部选项都失败，则表示匹配失败。·
```
"LiuBang" ~ /LiuBang|XiangYu|ZhangHan/ //返回"LiuBang"
"XiangYu" ~ /LiuBang|XiangYu|ZhangHan/ //返回"XiangYu"
"ZhangHan" ~ /LiuBang|XiangYu|ZhangHan/ //返回"ZhangHan"
"ZhaoGao" ~ /LiuBang|XiangYu|ZhangHan/ //返回null
```
